---
title: "Introduction to {photon}"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to {photon}}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include=FALSE}
library(photon)
options(photon_movers = FALSE)
```

This vignette is an introduction to the `{photon}` package, an interface to the [photon](https://photon.komoot.io/) geocoder developed by [komoot](https://www.komoot.com/). Photon is open-source, based on [OpenStreetMap](https://www.openstreetmap.org/) data, and powered by the [ElasticSearch](https://www.elastic.co/elasticsearch) search engine. It is -- according to komoot -- fast, scalable, multilingual, typo-tolerant, and up-to-date. Photon can do unstructured geocoding, reverse geocoding, and (under special circumstances) structured geocoding. Komoot offers a public photon API ([https://photon.komoot.io/]) but you can also set up a photon instance on a local machine.

`{photon}` supports both online and offline geocoding. Online geocoding through komoots public API is intriguing because it is convenient and offers up-to-date global coverage. It is appropriately easy to use online geocoding in `{photon}`. First, it is necessary to tell R that you want to use the public API. This can be done using the workhorse function `new_photon()`. To set up online geocoding, simply call it without parameters:

```{r public_api}
new_photon()
```

The created `photon` object is attached to the session and does not have to be stored manually. Now you can geocode.

```{r geocode}
cities <- geocode(c("Sanaa", "Caracas"), osm_tag = ":city")
```

Simiarly, you can also reverse geocode. `{photon}` fully supports `sf` objects so that all geocoding functions return `sf` dataframes and `reverse()` accepts `sf` and `sfc` objects as input.

```{r reverse}
reverse(cities, osm_tag = ":city")
```

Online geocoding is nice and it is most likely what you need for basic tasks. But what if online geocoding is not enough? What if you need to geocode a dataset of 200,000 places? What if you need to geocode sensitive information from survey respondents? And what about structured geocoding?


# Offline geocoding

The photon backend is freely available on the [photon GitHub repository](https://github.com/komoot/photon). With it, you can set up a local instance of photon. Offline geocoding is nice because it is extremely fast, versatile and it doesn't send your potentially sensitive data around the internet. In a lot of cases, offline geocoding is absolutely imperative, yet usually, setting up an offline geocoder can be quite cumbersome. `{photon}` takes over this task!

To run photon, you need Java 11 or higher. Setting up local photon also works through `new_photon()`. This time, we pass a path where the necessary files should be stored and a country for which a search index should be downloaded. While global coverage is also possible, the global search index is extremely large (around 80 GB). By default, `new_photon()` downloads a search index tagged with `latest` but it is also possible to query a search index created at a specific date.

```{r local_photon}
path <- file.path(tempdir(), "photon")
photon <- new_photon(path, country = "Samoa")
```

The resulting object is an R6 class with a few methods to control the instance. To start photon, run `$start()`. Here, you can also set photon options such as RAM to allocate or the port to listen to. Here, I use a maximum of 1 GB RAM because the search index of Samoa is rather small.

```{r start}
photon$start(min_ram = 1, max_ram = 1)
```

To check if the service is up and running, you can use `$is_ready()`.

```{r is_ready}
photon$is_ready()
```

Finally, to properly stop photon after you used it, you can run `$stop()`. You do not actually _need_ to run it manually, because it is (implicitly) executed on two occasions: 1. on garbage collection and 2. when the R session ends and external processes are killed.

```{r stop, eval=FALSE}
photon$stop()
```

To compare offline and online geocoding, let's benchmark them by geocoding the Samoan capital Apia:

```{r benchmark1}
# offline geocoding
bench::mark(geocode("Apai", limit = 1), iterations = 25)
```

```{r benchmark2}
# online geocoding
new_photon()
bench::mark(geocode("Apai", limit = 1), iterations = 25)
```

That is a speed increase by a factor of almost 50 (and possibly more on faster machines)!
